{"version":3,"file":"bundle-prisma.js","sources":["../src/prisma.ts"],"sourcesContent":["import { parse } from \"./index\";\r\n\r\nexport function createFilter<T extends Prisma>(prisma: T, tableName: keyof T, filterStr: string) {\r\n    const input = filterStr.trim()\r\n    const ast = parse.expr2(input)\r\n    if (!ast || ast.idx < input.length) return\r\n    const filter = transformExpr2(prisma, tableName as any, ast)\r\n    if (!(filter && \"_$metadata\" in filter)) return\r\n    return removeMetadata(filter)\r\n}\r\n\r\nfunction transformExpr2(prisma: any, tableName: string, ast: ReturnType<typeof parse.expr2>): any {\r\n    if (!ast) return\r\n    switch (ast.type) {\r\n        case \"term\": return transformTerm(prisma, tableName, ast)\r\n        case \"infix0-operation\": return transformInfix0Operation(prisma, tableName, ast)\r\n        case \"infix1-operation\": return transformInfix1Operation(prisma, tableName, ast)\r\n        case \"infix2-operation\": return transformInfix2Operation(prisma, tableName, ast)\r\n        case \"prefix-operation\": return transformPrefixOperation(prisma, tableName, ast)\r\n    }\r\n}\r\n\r\nfunction transformTerm(prisma: any, tableName: string, ast: ReturnType<typeof parse.term>): any {\r\n    if (!ast) return\r\n    switch (ast.value.type) {\r\n        case \"null\":\r\n        case \"boolean\":\r\n        case \"number\":\r\n        case \"string\": return ast.value.value\r\n        case \"name\": return transformName(prisma, tableName, ast.value)\r\n        case \"list\": return ast.value.value.map((x: any) => transformTerm(prisma, tableName, x))\r\n        case \"group\": return transformExpr2(prisma, tableName, ast.value.value)\r\n    }\r\n    return\r\n}\r\n\r\nfunction transformName(prisma: any, tableName: string, ast: any): any {\r\n    if (!ast) return\r\n\r\n    let obj: Record<string, any> = {}\r\n    const words = ast.words\r\n\r\n    const metadata = {\r\n        type: \"name\",\r\n        field: {} as any,\r\n        assign(prop: string, value: any) {\r\n            this.field[prop] = value\r\n        },\r\n        path: words.flatMap((x: any) => x.isArray ? [\"every\", x.value] : x.value) as string[],\r\n    }\r\n\r\n    for (let i = words.length - 1; i >= 0; i--) {\r\n        const { value, isArray } = words[i]\r\n        const field = i == words.length - 1 ? metadata.field : obj\r\n        obj = isArray ? { every: { [value]: field } } : { [value]: field }\r\n    }\r\n    obj._$metadata = metadata\r\n\r\n    return obj\r\n}\r\n\r\nfunction transformInfix0Operation(prisma: any, tableName: string, ast: any): any {\r\n    if (!ast) return\r\n    const { left, right, operator } = ast\r\n\r\n    const lhs = transformExpr2(prisma, tableName, left)\r\n\r\n    if (lhs === undefined) return\r\n\r\n    const rhs = transformExpr2(prisma, tableName, right)\r\n    if (rhs === undefined) return\r\n\r\n    const operators = {\r\n        lt: \"lt\",\r\n        gt: \"gt\",\r\n        eq: \"equals\",\r\n        lte: \"lte\",\r\n        gte: \"gte\",\r\n        in: \"in\",\r\n        noteq: \"not\",\r\n        notin: \"notIn\"\r\n    } as any\r\n\r\n    const oppositeOperators = {\r\n        lt: \"gt\",\r\n        gt: \"lt\",\r\n        eq: \"noteq\",\r\n        lte: \"gte\",\r\n        gte: \"lte\",\r\n        in: \"notin\",\r\n        noteq: \"eq\",\r\n        notin: \"in\"\r\n    } as any\r\n\r\n    const isLeftPrimitive = !hasProp(lhs, '_$metadata') || lhs === null || Array.isArray(lhs)\r\n    const isRightPrimitive = !hasProp(rhs, '_$metadata') || rhs === null || Array.isArray(rhs)\r\n\r\n    if (isLeftPrimitive && isRightPrimitive) return\r\n\r\n    if (isLeftPrimitive && !isRightPrimitive) {\r\n        const opr = operators[oppositeOperators[operator.value]]\r\n        if (!opr) return\r\n\r\n        rhs._$metadata.assign(opr, lhs)\r\n        return rhs\r\n    }\r\n\r\n    if (isRightPrimitive && !isLeftPrimitive) {\r\n        const opr = operators[operator.value]\r\n        if (!opr) return\r\n\r\n        if (lhs._$metadata.type != \"name\") return\r\n\r\n        lhs._$metadata.assign(opr, rhs)\r\n        return lhs\r\n    }\r\n\r\n    if (!isLeftPrimitive && !isRightPrimitive) {\r\n        const opr = operators[operator.value]\r\n        if (!opr) return\r\n\r\n        if (rhs._$metadata.path.length != 1) return\r\n\r\n        lhs._$metadata.assign(opr, prisma[tableName].fields[rhs._$metadata.path[0]])\r\n        return lhs\r\n    }\r\n\r\n    return\r\n}\r\n\r\nfunction transformInfix1Operation(prisma: any, tableName: string, ast: any): any {\r\n    if (!ast) return\r\n    const { left, right, operator } = ast\r\n    const operators = {\r\n        \"and\": \"AND\"\r\n    } as any\r\n\r\n    const lhs = transformExpr2(prisma, tableName, left)\r\n\r\n    if (lhs === undefined || !hasProp(lhs, '_$metadata')) return\r\n\r\n    const rhs = transformExpr2(prisma, tableName, right)\r\n\r\n    if (rhs === undefined) return lhs\r\n    if (!hasProp(rhs, '_$metadata')) return\r\n\r\n    const opr = operators[operator.value]\r\n    if (!opr) return\r\n\r\n    const metadata = {\r\n        type: \"infix1-operation\",\r\n        assign(prop: string, value: any) { }\r\n    }\r\n\r\n    return { [opr]: [lhs, rhs], _$metadata: metadata }\r\n}\r\n\r\nfunction transformInfix2Operation(prisma: any, tableName: string, ast: any): any {\r\n    if (!ast) return\r\n    const { left, right, operator } = ast\r\n    const operators = {\r\n        \"or\": \"OR\"\r\n    } as any\r\n\r\n    const lhs = transformExpr2(prisma, tableName, left)\r\n    if (lhs === undefined || !hasProp(lhs, '_$metadata')) return\r\n\r\n    const rhs = transformExpr2(prisma, tableName, right)\r\n\r\n    if (rhs === undefined) return lhs\r\n    if (!hasProp(rhs, '_$metadata')) return\r\n\r\n    const opr = operators[operator.value]\r\n\r\n    if (!opr) return\r\n\r\n    const metadata = {\r\n        type: \"infix2-operation\",\r\n        assign(prop: string, value: any) { }\r\n    }\r\n\r\n    return { [opr]: [lhs, rhs], _$metadata: metadata }\r\n}\r\n\r\nfunction transformPrefixOperation(prisma: any, tableName: string, ast: any): any {\r\n    if (!ast) return\r\n\r\n    const operators = {\r\n        \"not\": \"NOT\"\r\n    } as any\r\n\r\n    const { operator, operand } = ast\r\n    const term = transformTerm(prisma, tableName, operand)\r\n\r\n    if (term === undefined || !hasProp(term, '_$metadata')) return\r\n\r\n    const opr = operators[operator.value]\r\n    if (!opr) return\r\n\r\n    const metadata = {\r\n        type: \"prefix-operation\",\r\n        assign(prop: string, value: any) { }\r\n    }\r\n\r\n    return { [opr]: term, _$metadata: metadata }\r\n}\r\n\r\nfunction removeMetadata(obj: any) {\r\n    deepVisit(obj, (obj) => delete obj._$metadata)\r\n    return obj\r\n}\r\n\r\nfunction deepVisit(root: any, visit: (obj: any, prop: string | number, value: any) => void) {\r\n    switch (true) {\r\n        case Array.isArray(root): {\r\n            for (let i = 0; i < root.length; i++) {\r\n                deepVisit(root[i], visit)\r\n            }\r\n            break\r\n        }\r\n        case root && typeof root == \"object\": {\r\n            for (const key in root) {\r\n                visit(root, key, deepVisit(root[key], visit))\r\n            }\r\n            break\r\n        }\r\n    }\r\n    return root\r\n}\r\n\r\nfunction hasProp(obj: any, prop: any) {\r\n    return typeof obj == \"object\" && prop && prop in obj\r\n}\r\n\r\ntype Prisma = {\r\n    [model: string]: {\r\n        fields: {\r\n            [field: string]: {\r\n                isList: boolean,\r\n                modelName: string,\r\n                name: string,\r\n                typeName: string,\r\n            }\r\n        }\r\n    }\r\n}"],"names":["createFilter","prisma","tableName","filterStr","input","trim","ast","parse","expr2","idx","length","filter","transformExpr2","obj","deepVisit","_$metadata","type","transformTerm","left","right","operator","lhs","undefined","rhs","operators","lt","gt","eq","lte","gte","in","noteq","notin","oppositeOperators","isLeftPrimitive","hasProp","Array","isArray","isRightPrimitive","opr","value","assign","path","fields","transformInfix0Operation","and","metadata","prop","transformInfix1Operation","or","transformInfix2Operation","not","operand","term","transformPrefixOperation","words","field","this","flatMap","x","i","every","transformName","map","root","visit","key"],"mappings":"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"}