import{parse as t}from"./bundle-index.js";function e(e,r,i){const o=i.trim(),s=t.expr2(o);if(!s||s.idx<o.length)return;const u=n(e,r,s);var f;return u&&"_$metadata"in u?(a(f=u,(t=>delete t._$metadata)),f):void 0}function n(t,e,a){if(a)switch(a.type){case"term":return r(t,e,a);case"infix0-operation":return function(t,e,r){if(!r)return;const{left:a,right:o,operator:s}=r,u=n(t,e,a);if(void 0===u)return;const f=n(t,e,o);if(void 0===f)return;const c={lt:"lt",gt:"gt",eq:"equals",lte:"lte",gte:"gte",in:"in",noteq:"not",notin:"notIn",has:"contains",begins:"startsWith",ends:"endsWith"},l={lt:"gt",gt:"lt",eq:"noteq",lte:"gte",gte:"lte",in:"notin",noteq:"eq",notin:"in",has:"has",begins:"ends",ends:"begins"},d=!i(u,"_$metadata")||null===u||Array.isArray(u),p=!i(f,"_$metadata")||null===f||Array.isArray(f);if(d&&p)return;if(d&&!p){const t=c[l[s.value]];if(!t)return;return f._$metadata.assign(t,u),f}if(p&&!d){const t=c[s.value];if(!t)return;if("name"!=u._$metadata.type)return;return u._$metadata.assign(t,f),u}if(!d&&!p){const n=c[s.value];if(!n)return;if(1!=f._$metadata.path.length)return;return u._$metadata.assign(n,t[e].fields[f._$metadata.path[0]]),u}return}(t,e,a);case"infix1-operation":return function(t,e,r){if(!r)return;const{left:a,right:o,operator:s}=r,u={and:"AND"},f=n(t,e,a);if(void 0===f||!i(f,"_$metadata"))return;const c=n(t,e,o);if(void 0===c)return f;if(!i(c,"_$metadata"))return;const l=u[s.value];if(!l)return;const d={type:"infix1-operation",assign(t,e){}};return{[l]:[f,c],_$metadata:d}}(t,e,a);case"infix2-operation":return function(t,e,r){if(!r)return;const{left:a,right:o,operator:s}=r,u={or:"OR"},f=n(t,e,a);if(void 0===f||!i(f,"_$metadata"))return;const c=n(t,e,o);if(void 0===c)return f;if(!i(c,"_$metadata"))return;const l=u[s.value];if(!l)return;const d={type:"infix2-operation",assign(t,e){}};return{[l]:[f,c],_$metadata:d}}(t,e,a);case"prefix-operation":return function(t,e,n){if(!n)return;const a={not:"NOT"},{operator:o,operand:s}=n,u=r(t,e,s);if(void 0===u||!i(u,"_$metadata"))return;const f=a[o.value];if(!f)return;const c={type:"prefix-operation",assign(t,e){}};return{[f]:u,_$metadata:c}}(t,e,a)}}function r(t,e,a){if(a)switch(a.value.type){case"null":case"boolean":case"number":case"string":return a.value.value;case"name":return function(t,e,n){if(!n)return;let r={};const a=n.words,i={type:"name",field:{},assign(t,e){this.field[t]=e},path:a.flatMap((t=>t.isArray?["every",t.value]:t.value))};for(let t=a.length-1;t>=0;t--){const{value:e,isArray:n}=a[t],o=t==a.length-1?i.field:r;r=n?{every:{[e]:o}}:{[e]:o}}return r._$metadata=i,r}(0,0,a.value);case"list":return a.value.value.map((n=>r(t,e,n)));case"group":return n(t,e,a.value.value)}}function a(t,e){switch(!0){case Array.isArray(t):for(let n=0;n<t.length;n++)a(t[n],e);break;case t&&"object"==typeof t:for(const n in t)e(t,n,a(t[n],e))}return t}function i(t,e){return"object"==typeof t&&e&&e in t}export{e as createFilter};
//# sourceMappingURL=bundle-prisma.js.map
